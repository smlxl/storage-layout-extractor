//! This module contains the definition of the [`SymbolicValue`] and its
//! supporting types.

pub mod known_data;

use derivative::Derivative;
use uuid::Uuid;

use crate::vm::symbolic_value::known_data::KnownData;

/// A symbolic value is an "execution tree" that records the informative
/// operations that are made to a piece of data. Note that the
/// `instruction_pointer` and `synthetic` flag is ignored for the purposes of
/// equality and hashing.
///
/// # Synthetic Values
///
/// Data is considered to be synthetic when it was generated by the analysis
/// process to more concretely represent an operation.
#[derive(Clone, Debug, Eq, Derivative)]
#[derivative(Hash, PartialEq)]
pub struct SymbolicValue {
    /// The instruction pointer's value at the location where this part of the
    /// symbolic execution tree was recorded.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub instruction_pointer: u32,

    /// Where the data at this level came from.
    pub provenance: Provenance,

    /// The actual execution tree that forms this value.
    pub data: SymbolicValueData,
}

impl SymbolicValue {
    /// Constructs a new, `SymbolicValue` representing the operation performed
    /// at `instruction_pointer` on the symbolic `data` and with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    fn new(instruction_pointer: u32, data: SymbolicValueData, provenance: Provenance) -> Box<Self> {
        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Constructs a new `SymbolicValue` representing the operation performed at
    /// `instruction_pointer` on the symbolic `data`. It is created with a
    /// provenance of [`Provenance::ProgramCode`] to indicate that the symbolic
    /// execution of the program created the value.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_from_program(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::ProgramCode)
    }

    /// Constructs a new, synthetic, `SymbolicValue` representing the operation
    /// performed at `instruction_pointer` on the symbolic `data`. It is created
    /// with a provenance of [`Provenance::Synthetic`] to indicate that it was
    /// generated by the analysis process.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_synthetic(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Synthetic)
    }

    /// Constructs a new `SymbolicValue` representing a symbolic value created
    /// at `instruction_pointer` with the provided `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_value(instruction_pointer: u32, provenance: Provenance) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::default(),
            provenance,
        )
    }

    /// Constructs a new `SymbolicValue` representing a known value of
    /// `value_data` created at `instruction_pointer` with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_known_value(
        instruction_pointer: u32,
        value_data: KnownData,
        provenance: Provenance,
    ) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::KnownData {
                id:    Uuid::new_v4(),
                value: value_data,
            },
            provenance,
        )
    }

    /// Compares two symbolic values for strict equality, _including_ the value
    /// of the `instruction_pointer` and `synthetic` flag.
    pub fn strict_eq(&self, other: &Self) -> bool {
        self.instruction_pointer == other.instruction_pointer && self == other
    }
}

/// The type of a boxed symbolic value.
pub type BoxedVal = Box<SymbolicValue>;

/// The execution tree structures that allow the executor to build traces of the
/// execution pertaining to certain symbolic values.
///
/// Note that these do not duplicate the opcodes 1:1, instead representing the
/// opcode operations that _provide information about the type of a value_ as an
/// execution tree. Notable (and intentional) omissions here are the opcodes
/// that deal with memory, storage, and the stack.
///
/// # Semantics
///
/// For the semantics of these operations at runtime, please see the
/// corresponding documentation comments in the [`crate::opcode`] subtree.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum SymbolicValueData {
    /// A value with identity, but about which nothing else is known.
    Value { id: Uuid },

    /// A value that has is made up of a known sequence of bytes.
    ///
    /// It has an `id` in order to allow the program to distinguish the same
    /// value created in different places.
    KnownData { id: Uuid, value: KnownData },

    /// Addition of symbolic values.
    Add { left: BoxedVal, right: BoxedVal },

    /// Multiplication of symbolic values.
    Mul { left: BoxedVal, right: BoxedVal },

    /// Subtraction of symbolic values.
    Sub { left: BoxedVal, right: BoxedVal },

    /// Division of symbolic values.
    Div { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed division of symbolic values.
    SDiv { dividend: BoxedVal, divisor: BoxedVal },

    /// Modulo of symbolic values.
    Mod { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed modulo of symbolic values.
    SMod { dividend: BoxedVal, divisor: BoxedVal },

    /// Addition followed by modulo.
    AddMod { left: BoxedVal, right: BoxedVal, exponent: BoxedVal },

    /// Multiplication followed by modulo.
    MulMod { left: BoxedVal, right: BoxedVal, exponent: BoxedVal },

    /// Exponentiation of symbolic values.
    Exp { value: BoxedVal, exponent: BoxedVal },

    /// Sign extension of a symbolic value to a symbolic length.
    SignExtend { size: BoxedVal, value: BoxedVal },

    /// Program counter.
    ProgramCounter,

    /// A standard message call.
    Call {
        gas:        BoxedVal,
        address:    BoxedVal,
        value:      BoxedVal,
        arg_offset: BoxedVal,
        arg_size:   BoxedVal,
        ret_offset: BoxedVal,
        ret_size:   BoxedVal,
    },

    /// A `CALLCODE` message call.
    CallCode {
        gas:        BoxedVal,
        address:    BoxedVal,
        value:      BoxedVal,
        arg_offset: BoxedVal,
        arg_size:   BoxedVal,
        ret_offset: BoxedVal,
        ret_size:   BoxedVal,
    },

    /// A `DELEGATECALL` message call.
    DelegateCall {
        gas:        BoxedVal,
        address:    BoxedVal,
        value:      BoxedVal,
        arg_offset: BoxedVal,
        arg_size:   BoxedVal,
        ret_offset: BoxedVal,
        ret_size:   BoxedVal,
    },

    /// A `STATICCALL` message call.
    StaticCall {
        gas:        BoxedVal,
        address:    BoxedVal,
        value:      BoxedVal,
        arg_offset: BoxedVal,
        arg_size:   BoxedVal,
        ret_offset: BoxedVal,
        ret_size:   BoxedVal,
    },

    /// A keccak256 hash on symbolic values.
    Sha3 { offset: BoxedVal, size: BoxedVal },

    /// The address of the currently-executing contract.
    Address,

    /// The balance of the target account.
    Balance { address: BoxedVal },

    /// The address of the transaction's origin.
    Origin,

    /// The caller of the transaction.
    Caller,

    /// The value deposited by the caller.
    CallValue,

    /// The current gas price.
    GasPrice,

    /// Compute the external code hash of a symbolic value.
    ExtCodeHash { address: BoxedVal },

    /// Gets the block hash from one of the
    BlockHash { block_number: u8 },

    /// Gets the block's beneficiary address.
    CoinBase,

    /// Gets the timestamp of the current block.
    Timestamp,

    /// Gets the number of the current block.
    Number,

    /// Gets the difficulty of the current block.
    Difficulty,

    /// Gets the gas limit of  the current block.
    GasLimit,

    /// Gets the identifier for the chain on which the current block is
    /// executing.
    ChainId,

    /// Gets the balance of the currently executing account.
    SelfBalance,

    /// Gets the block base fee.
    BaseFee,

    /// Gets the currently available gas.
    Gas,

    /// Creates a new contract.
    Create { value: BoxedVal, offset: BoxedVal, size: BoxedVal },

    /// Creates a new contract at a predictable address.
    Create2 {
        value:  BoxedVal,
        offset: BoxedVal,
        size:   BoxedVal,
        salt:   BoxedVal,
    },

    /// Registers the account for deletion.
    SelfDestruct { target: BoxedVal },

    /// Less than for symbolic values.
    Lt { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values.
    Gt { left: BoxedVal, right: BoxedVal },

    /// Less than for symbolic values where the values are signed.
    SLt { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values where the values are signed.
    SGt { left: BoxedVal, right: BoxedVal },

    /// Equality for symbolic values.
    Eq { left: BoxedVal, right: BoxedVal },

    /// Checking if a symbolic value is zero.
    IsZero { number: BoxedVal },

    /// Logical conjunction for symbolic values.
    And { left: BoxedVal, right: BoxedVal },

    /// Logical disjunction for symbolic values.
    Or { left: BoxedVal, right: BoxedVal },

    /// XOR for symbolic values.
    Xor { left: BoxedVal, right: BoxedVal },

    /// Negation of a symbolic value.
    Not { bool: BoxedVal },

    /// Gets a byte from a word.
    Byte { offset: BoxedVal, value: BoxedVal },

    /// Left shift with symbolic values.
    Shl { shift: BoxedVal, value: BoxedVal },

    /// Right shift with symbolic values.
    Shr { shift: BoxedVal, value: BoxedVal },

    /// Signed right shift with symbolic values.
    Sar { shift: BoxedVal, value: BoxedVal },

    /// The size of the current call data.
    CallDataSize,

    /// Copies the calldata into memory.
    CallDataCopy {
        dest_offset: BoxedVal,
        offset:      BoxedVal,
        size:        BoxedVal,
    },

    /// Gets the code size of the VM.
    CodeSize,

    /// Copies the code from the current contract into memory.
    CodeCopy {
        dest_offset: BoxedVal,
        offset:      BoxedVal,
        size:        BoxedVal,
    },

    /// Gets the code size of the target contract.
    ExtCodeSize { address: BoxedVal },

    /// Copies the code from an external contract into memory.
    ExtCodeCopy {
        address:     BoxedVal,
        dest_offset: BoxedVal,
        offset:      BoxedVal,
        size:        BoxedVal,
    },

    /// Gets the size of the return data from the previous call.
    ReturnDataSize,

    /// Copies the return data from the previous call into memory.
    ReturnDataCopy {
        dest_offset: BoxedVal,
        offset:      BoxedVal,
        size:        BoxedVal,
    },
}

/// The default value for a symbolic value's data is a [`SymbolicValue::Value`]
/// about which nothing else is known.
impl Default for SymbolicValueData {
    fn default() -> Self {
        SymbolicValueData::Value { id: Uuid::new_v4() }
    }
}

/// A descriptor for where a symbolic value originated in the program.
///
/// In essence, these can be thought of as tags that provide more information
/// about the given value.
#[derive(Clone, Debug, Eq, Hash, Derivative, PartialEq)]
pub enum Provenance {
    /// The value originated in a read from call data.
    CallData,

    /// The value originated from the result of the `CALLDATASIZE` opcode.
    CallDataSize,

    /// The value deposited by the caller.
    CallValue,

    /// The value originated from the result of the `GAS` opcode.
    Gas,

    /// The value originated in operations performed by the bytecode.
    ProgramCode,

    /// The value originated from a read of the current program counter.
    ProgramCounter,

    /// The value originated from the `RETURNDATASIZE` opcode.
    ReturnDataSize,

    /// The value originated from the `SELFBALANCE` opcode.
    SelfBalance,

    /// The value was constructed by the analysis in order to aid the process.
    Synthetic,

    /// The value originated from an `MLOAD` from uninitialized memory.
    UninitializedMemory { key: BoxedVal },

    /// The value originated from an `SLOAD` from uninitialized storage.
    UninitializedStorage { key: BoxedVal },

    /// There is no concrete source for this variable.
    Unknown,
}

#[cfg(test)]
mod test {
    use uuid::Uuid;

    use crate::vm::symbolic_value::{SymbolicValue, SymbolicValueData};

    #[test]
    fn equality_ignores_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(0, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn equality_includes_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_program(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert_ne!(value_1, value_2);
    }

    #[test]
    fn strict_equality_includes_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }
}
