//! This module contains the definition of the [`SymbolicValue`] and its
//! supporting types.

pub mod known;

use std::fmt::{Display, Formatter};

use derivative::Derivative;
use uuid::Uuid;

use crate::vm::value::known::KnownWord;

/// An alias recommended for use when you have to write it out often.
pub type SV = SymbolicValue;

/// A symbolic value is an "execution tree" that records the informative
/// operations that are made to a piece of data. Note that the
/// `instruction_pointer` and `synthetic` flag is ignored for the purposes of
/// equality and hashing.
///
/// # Synthetic Values
///
/// Data is considered to be synthetic when it was generated by the analysis
/// process to more concretely represent an operation.
#[derive(Clone, Debug, Eq, Derivative)]
#[derivative(Hash, PartialEq)]
pub struct SymbolicValue {
    /// The instruction pointer's value at the location where this part of the
    /// symbolic execution tree was recorded.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub instruction_pointer: u32,

    /// Where the data at this level came from.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub provenance: Provenance,

    /// The actual execution tree that forms this value.
    pub data: SymbolicValueData,
}

impl SymbolicValue {
    /// Constructs a new, `SymbolicValue` representing the operation performed
    /// at `instruction_pointer` on the symbolic `data` and with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    #[must_use]
    pub fn new(
        instruction_pointer: u32,
        data: SymbolicValueData,
        provenance: Provenance,
    ) -> Box<Self> {
        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Constructs a new `SymbolicValue` representing the operation performed at
    /// `instruction_pointer` on the symbolic `data`. It is created with a
    /// provenance of [`Provenance::Execution`] to indicate that the symbolic
    /// execution of the program created the value.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    #[must_use]
    pub fn new_from_execution(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Execution)
    }

    /// Constructs a new, synthetic, `SymbolicValue` representing the operation
    /// performed at `instruction_pointer` on the symbolic `data`. It is created
    /// with a provenance of [`Provenance::Synthetic`] to indicate that it was
    /// generated by the analysis process.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    #[must_use]
    pub fn new_synthetic(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Synthetic)
    }

    /// Constructs a new `SymbolicValue` representing a symbolic value created
    /// at `instruction_pointer` with the provided `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    #[must_use]
    pub fn new_value(instruction_pointer: u32, provenance: Provenance) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::new_value(),
            provenance,
        )
    }

    /// Constructs a new `SymbolicValue` representing a known value of
    /// `value_data` created at `instruction_pointer` with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    #[must_use]
    pub fn new_known_value(
        instruction_pointer: u32,
        value_data: KnownWord,
        provenance: Provenance,
    ) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::KnownData { value: value_data },
            provenance,
        )
    }

    /// Compares two symbolic values for strict equality, _including_ the value
    /// of the `instruction_pointer`.
    #[must_use]
    pub fn strict_eq(&self, other: &Self) -> bool {
        self.instruction_pointer == other.instruction_pointer && self == other
    }

    /// Performs constant folding on immediates wherever possible.
    ///
    /// This means that it will go through the entire value to find any
    /// opportunities where all the operands to a node are
    /// [`SymbolicValueData::KnownData`]s that can be combined statically.
    ///
    /// # Note
    ///
    /// This algorithm is recursive. If it turns out to be a problem in practice
    /// it can be re-written.
    #[must_use]
    pub fn constant_fold(self) -> BoxedVal {
        let data = self.data.constant_fold();
        let instruction_pointer = self.instruction_pointer;
        let provenance = self.provenance;

        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Checks if the payload is known data.
    #[must_use]
    pub fn is_known_data(&self) -> bool {
        matches!(self.data, SymbolicValueData::KnownData { .. })
    }

    /// Converts the payload into a VM word if possible.
    #[must_use]
    pub fn as_word(&self) -> Option<KnownWord> {
        match &self.data {
            SymbolicValueData::KnownData { value } => Some(*value),
            _ => None,
        }
    }

    /// Transforms the payload data of the symbolic value by processing
    /// `self.data` with the `transform`.
    #[must_use]
    pub fn transform_data(
        self,
        transform: impl Fn(&SymbolicValueData) -> Option<SymbolicValueData> + Copy,
    ) -> BoxedVal {
        Self::new(
            self.instruction_pointer,
            self.data.transform(transform),
            self.provenance,
        )
    }

    /// Gets all of the child nodes of this node.
    #[must_use]
    pub fn children(&self) -> Vec<&BoxedVal> {
        self.data.children()
    }
}

impl Display for SymbolicValue {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.data)
    }
}

/// The type of a boxed symbolic value.
pub type BoxedVal = Box<SymbolicValue>;

/// An alias recommended for use when you have to write it out often.
pub type SVD = SymbolicValueData;

/// The execution tree structures that allow the executor to build traces of the
/// execution pertaining to certain symbolic values.
///
/// Note that these do not duplicate the opcodes 1:1, instead representing the
/// opcode operations that _provide information about the type of a value_ as an
/// execution tree. Notable (and intentional) omissions here are the opcodes
/// that deal with memory, storage, and the stack.
///
/// # Semantics
///
/// For the semantics of these operations at runtime, please see the
/// corresponding documentation comments in the [`crate::opcode`] subtree.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum SymbolicValueData {
    /// A value with identity, but about which nothing else is known.
    Value { id: Uuid },

    /// A value that has is made up of a known sequence of bytes.
    KnownData { value: KnownWord },

    /// Addition of symbolic values.
    Add { left: BoxedVal, right: BoxedVal },

    /// Multiplication of symbolic values.
    Multiply { left: BoxedVal, right: BoxedVal },

    /// Subtraction of symbolic values.
    Subtract { left: BoxedVal, right: BoxedVal },

    /// Division of symbolic values.
    Divide { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed division of symbolic values.
    SignedDivide { dividend: BoxedVal, divisor: BoxedVal },

    /// Modulo of symbolic values.
    Modulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed modulo of symbolic values.
    SignedModulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Exponentiation of symbolic values.
    Exp { value: BoxedVal, exponent: BoxedVal },

    /// Sign extension of a symbolic value to a symbolic length.
    SignExtend { size: BoxedVal, value: BoxedVal },

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the return data in the opcode, as we know nothing
    /// about what the call will do with the argument. Internal execution will
    /// read from memory directly, so we pick up the returned value there.
    CallWithValue {
        gas:           BoxedVal,
        address:       BoxedVal,
        value:         BoxedVal,
        argument_data: BoxedVal,
        ret_offset:    BoxedVal,
        ret_size:      BoxedVal,
    },

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the return data in the opcode, as we know nothing
    /// about what the call will do with the argument. Internal execution will
    /// read from memory directly, so we pick up the returned value there.
    CallWithoutValue {
        gas:           BoxedVal,
        address:       BoxedVal,
        argument_data: BoxedVal,
        ret_offset:    BoxedVal,
        ret_size:      BoxedVal,
    },

    /// A keccak256 hash on symbolic values.
    Sha3 { data: BoxedVal },

    /// The address of the currently-executing contract.
    Address,

    /// The balance of the target account.
    Balance { address: BoxedVal },

    /// The address of the transaction's origin.
    Origin,

    /// The caller of the transaction.
    Caller,

    /// The value deposited by the caller.
    CallValue,

    /// The current gas price.
    GasPrice,

    /// Compute the external code hash of a symbolic value.
    ExtCodeHash { address: BoxedVal },

    /// Gets the block hash from one of the
    BlockHash { block_number: BoxedVal },

    /// Gets the block's beneficiary address.
    CoinBase,

    /// Gets the timestamp of the current block.
    BlockTimestamp,

    /// Gets the number of the current block.
    BlockNumber,

    /// Gets the difficulty of the current block.
    Prevrandao,

    /// Gets the gas limit of  the current block.
    GasLimit,

    /// Gets the identifier for the chain on which the current block is
    /// executing.
    ChainId,

    /// Gets the balance of the currently executing account.
    SelfBalance,

    /// Gets the block base fee.
    BaseFee,

    /// Gets the currently available gas.
    Gas,

    /// Logs the `value` from memory of `size` with the provided `topics`.
    Log { data: BoxedVal, topics: Vec<BoxedVal> },

    /// Creates a new contract.
    Create { value: BoxedVal, data: BoxedVal },

    /// Creates a new contract at a predictable address.
    Create2 { value: BoxedVal, salt: BoxedVal, data: BoxedVal },

    /// Registers the account for deletion.
    SelfDestruct { target: BoxedVal },

    /// Less than for symbolic values.
    LessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values.
    GreaterThan { left: BoxedVal, right: BoxedVal },

    /// Less than for symbolic values where the values are signed.
    SignedLessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values where the values are signed.
    SignedGreaterThan { left: BoxedVal, right: BoxedVal },

    /// Equality for symbolic values.
    Equals { left: BoxedVal, right: BoxedVal },

    /// Checking if a symbolic value is zero.
    IsZero { number: BoxedVal },

    /// Logical conjunction for symbolic values.
    And { left: BoxedVal, right: BoxedVal },

    /// Logical disjunction for symbolic values.
    Or { left: BoxedVal, right: BoxedVal },

    /// XOR for symbolic values.
    Xor { left: BoxedVal, right: BoxedVal },

    /// Negation of a symbolic value.
    Not { value: BoxedVal },

    /// Left shift with symbolic values.
    LeftShift { shift: BoxedVal, value: BoxedVal },

    /// Right shift with symbolic values.
    RightShift { shift: BoxedVal, value: BoxedVal },

    /// Signed right shift with symbolic values.
    ArithmeticRightShift { shift: BoxedVal, value: BoxedVal },

    /// Loading the data at `offset` for `size` in the call data.
    ///
    /// Note that CallData has non-structural identity.
    CallData { id: Uuid, offset: BoxedVal, size: BoxedVal },

    /// The size of the current call data.
    CallDataSize,

    /// Data copied from the code of the current contract starting at `offset`
    /// for `size`.
    CodeCopy { offset: BoxedVal, size: BoxedVal },

    /// Gets the code size of the target contract.
    ExtCodeSize { address: BoxedVal },

    /// Data copied from the code of the contract at `address` starting at
    /// `offset` for `size`.
    ExtCodeCopy { address: BoxedVal, offset: BoxedVal, size: BoxedVal },

    /// Data copied from the return data from the previous call at `offset` for
    /// `size`.
    ReturnData { offset: BoxedVal, size: BoxedVal },

    /// The return. Does not stay on the stack but is stored nevertheless.
    Return { data: BoxedVal },

    /// The revert. Does not stay on the stack but is stored nevertheless.
    Revert { data: BoxedVal },

    /// A value that was used as the input to a conditional.
    Condition { value: BoxedVal },

    /// The value read from storage that has not been written to at the time of
    /// loading during the course of execution in the virtual machine.
    UnwrittenStorageValue { key: BoxedVal },

    /// A value representing the return from a storage load at `key`.
    ///
    /// If there is no value in the storage slot for `key`, `value` will be
    /// [`Self::UnwrittenStorageValue`].
    SLoad { key: BoxedVal, value: BoxedVal },

    /// A storage slot at `index`.
    StorageSlot { key: BoxedVal },

    /// A representation of the storing of `value` at `key` in storage
    StorageWrite { key: BoxedVal, value: BoxedVal },

    /// The concatenation of multiple values.
    Concat { values: Vec<BoxedVal> },

    /// The value is a mapping address for storage `slot` with `key`.
    MappingAccess { slot: BoxedVal, key: BoxedVal },

    /// The value is an access to a dynamic array in `slot` at `index`.
    DynamicArrayAccess { slot: BoxedVal, index: BoxedVal },

    /// An operation that masks `value` to construct a sub-word value.
    ///
    /// The sub-word value begins at `offset` (0-based in bits where 0 is the
    /// LSB) in the overarching word, and with `size` (in bits).
    SubWord { value: BoxedVal, offset: usize, size: usize },

    /// An operation that shifts `value` to begin at `offset` within the
    /// containing word.
    ///
    /// Note that `offset` is the 0-indexed bit where the value begins.
    Shifted { offset: usize, value: BoxedVal },

    /// A packed encoding of data as a value, containing `elements`.
    Packed { elements: Vec<PackedSpan> },
}

impl SymbolicValueData {
    /// Constructs a new [`Self::KnownData`] containing the data `value`.
    #[must_use]
    pub fn new_known(value: KnownWord) -> Self {
        SymbolicValueData::KnownData { value }
    }

    /// Constructs a new [`Self::Value`] about which only its existence and
    /// identity are known.
    #[must_use]
    pub fn new_value() -> Self {
        let id = Uuid::new_v4();
        SymbolicValueData::Value { id }
    }

    /// Constructs a new [`Self::CallData`] instance with identity.
    #[must_use]
    pub fn call_data(offset: BoxedVal, size: BoxedVal) -> Self {
        let id = Uuid::new_v4();
        Self::CallData { id, offset, size }
    }

    /// Transforms the data payload by applying `transform` to it.
    ///
    /// It operates recursively on the entire tree, applying the transformation
    /// at the first opportunity. If you do not write `transform` carefully,
    /// this means that it may short-circuit other opportunities for
    /// transformation.
    ///
    /// # Note
    ///
    /// This algorithm is recursive. If it turns out to be a problem in practice
    /// it can be re-written.
    #[allow(clippy::match_same_arms, clippy::too_many_lines)]
    #[must_use]
    pub fn transform(self, transform: impl Fn(&Self) -> Option<Self> + Copy) -> Self {
        match transform(&self) {
            Some(data) => data,
            None => match self {
                Self::Value { .. } => self,
                Self::KnownData { .. } => self,
                Self::Add { left, right } => Self::Add {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Multiply { left, right } => Self::Multiply {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Subtract { left, right } => Self::Subtract {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Divide { divisor, dividend } => Self::Divide {
                    dividend: dividend.transform_data(transform),
                    divisor:  divisor.transform_data(transform),
                },
                Self::SignedDivide { divisor, dividend } => Self::SignedDivide {
                    dividend: dividend.transform_data(transform),
                    divisor:  divisor.transform_data(transform),
                },
                Self::Modulo { divisor, dividend } => Self::Modulo {
                    dividend: dividend.transform_data(transform),
                    divisor:  divisor.transform_data(transform),
                },
                Self::SignedModulo { divisor, dividend } => Self::SignedModulo {
                    dividend: dividend.transform_data(transform),
                    divisor:  divisor.transform_data(transform),
                },
                Self::Exp { value, exponent } => Self::Exp {
                    value:    value.transform_data(transform),
                    exponent: exponent.transform_data(transform),
                },
                Self::SignExtend { size, value } => Self::SignExtend {
                    size:  size.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::CallWithValue {
                    gas,
                    address,
                    value,
                    argument_data,
                    ret_offset,
                    ret_size,
                } => Self::CallWithValue {
                    gas:           gas.transform_data(transform),
                    address:       address.transform_data(transform),
                    value:         value.transform_data(transform),
                    argument_data: argument_data.transform_data(transform),
                    ret_offset:    ret_offset.transform_data(transform),
                    ret_size:      ret_size.transform_data(transform),
                },
                Self::CallWithoutValue {
                    gas,
                    address,
                    argument_data,
                    ret_offset,
                    ret_size,
                } => Self::CallWithoutValue {
                    gas:           gas.transform_data(transform),
                    address:       address.transform_data(transform),
                    argument_data: argument_data.transform_data(transform),
                    ret_offset:    ret_offset.transform_data(transform),
                    ret_size:      ret_size.transform_data(transform),
                },
                Self::Sha3 { data } => Self::Sha3 {
                    data: data.transform_data(transform),
                },
                Self::Address => self,
                Self::Balance { address } => Self::Balance {
                    address: address.transform_data(transform),
                },
                Self::Origin => self,
                Self::Caller => self,
                Self::CallValue => self,
                Self::GasPrice => self,
                Self::ExtCodeHash { address } => Self::ExtCodeHash {
                    address: address.transform_data(transform),
                },
                Self::BlockHash { block_number } => Self::BlockHash {
                    block_number: block_number.transform_data(transform),
                },
                Self::CoinBase => self,
                Self::BlockTimestamp => self,
                Self::BlockNumber => self,
                Self::Prevrandao => self,
                Self::GasLimit => self,
                Self::ChainId => self,
                Self::SelfBalance => self,
                Self::BaseFee => self,
                Self::Gas => self,
                Self::Log { data, topics } => Self::Log {
                    data:   data.transform_data(transform),
                    topics: topics.into_iter().map(|t| t.transform_data(transform)).collect(),
                },
                Self::Create { value, data } => Self::Create {
                    value: value.transform_data(transform),
                    data:  data.transform_data(transform),
                },
                Self::Create2 { value, data, salt } => Self::Create2 {
                    value: value.transform_data(transform),
                    data:  data.transform_data(transform),
                    salt:  salt.transform_data(transform),
                },
                Self::SelfDestruct { target } => Self::SelfDestruct {
                    target: target.transform_data(transform),
                },
                Self::LessThan { left, right } => Self::LessThan {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::GreaterThan { left, right } => Self::GreaterThan {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::SignedLessThan { left, right } => Self::SignedLessThan {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::SignedGreaterThan { left, right } => Self::SignedGreaterThan {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Equals { left, right } => Self::Equals {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::IsZero { number } => Self::IsZero {
                    number: number.transform_data(transform),
                },
                Self::And { left, right } => Self::And {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Or { left, right } => Self::Or {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Xor { left, right } => Self::Xor {
                    left:  left.transform_data(transform),
                    right: right.transform_data(transform),
                },
                Self::Not { value } => Self::Not {
                    value: value.transform_data(transform),
                },
                Self::LeftShift { shift, value } => Self::LeftShift {
                    shift: shift.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::RightShift { shift, value } => Self::RightShift {
                    shift: shift.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::ArithmeticRightShift { shift, value } => Self::ArithmeticRightShift {
                    shift: shift.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::CallData { id, offset, size } => Self::CallData {
                    id,
                    offset: offset.transform_data(transform),
                    size: size.transform_data(transform),
                },
                Self::CallDataSize => self,
                Self::CodeCopy { offset, size } => Self::CodeCopy {
                    offset: offset.transform_data(transform),
                    size:   size.transform_data(transform),
                },
                Self::ExtCodeSize { address } => Self::ExtCodeSize {
                    address: address.transform_data(transform),
                },
                Self::ExtCodeCopy {
                    address,
                    offset,
                    size,
                } => Self::ExtCodeCopy {
                    address: address.transform_data(transform),
                    offset:  offset.transform_data(transform),
                    size:    size.transform_data(transform),
                },
                Self::ReturnData { offset, size } => Self::ReturnData {
                    offset: offset.transform_data(transform),
                    size:   size.transform_data(transform),
                },
                Self::Return { data } => Self::Return {
                    data: data.transform_data(transform),
                },
                Self::Revert { data } => Self::Revert {
                    data: data.transform_data(transform),
                },
                Self::Condition { value } => Self::Condition {
                    value: value.transform_data(transform),
                },
                Self::UnwrittenStorageValue { key } => Self::UnwrittenStorageValue {
                    key: key.transform_data(transform),
                },
                Self::SLoad { key, value } => Self::SLoad {
                    key:   key.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::StorageSlot { key } => Self::StorageSlot {
                    key: key.transform_data(transform),
                },
                Self::StorageWrite { key, value } => Self::StorageWrite {
                    key:   key.transform_data(transform),
                    value: value.transform_data(transform),
                },
                Self::Concat { values } => Self::Concat {
                    values: values.into_iter().map(|v| v.transform_data(transform)).collect(),
                },
                Self::MappingAccess { slot, key } => Self::MappingAccess {
                    slot: slot.transform_data(transform),
                    key:  key.transform_data(transform),
                },
                Self::DynamicArrayAccess { slot, index } => Self::DynamicArrayAccess {
                    slot:  slot.transform_data(transform),
                    index: index.transform_data(transform),
                },
                Self::SubWord {
                    value,
                    offset,
                    size,
                } => Self::SubWord {
                    value: value.transform_data(transform),
                    offset,
                    size,
                },
                Self::Shifted { offset, value } => Self::Shifted {
                    offset,
                    value: value.transform_data(transform),
                },
                Self::Packed { elements } => Self::Packed {
                    elements: elements.into_iter().map(|elem| elem.transform(transform)).collect(),
                },
            },
        }
    }

    /// Performs constant folding on immediates wherever possible.
    ///
    /// This means that it will go through the entire value to find any
    /// opportunities where all the operands to a node are [`Self::KnownData`]s
    /// that can be combined statically.
    ///
    /// # Note
    ///
    /// This algorithm is recursive. If it turns out to be a problem in practice
    /// it can be re-written.
    #[allow(clippy::match_same_arms, clippy::too_many_lines)]
    #[must_use]
    pub fn constant_fold(self) -> Self {
        // The inner definition that actually implements the constant folding operation.
        #[allow(clippy::too_many_lines)]
        fn constant_folder(data: &SVD) -> Option<SVD> {
            match data.clone() {
                SVD::Add { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a + b),
                        _ => SVD::Add { left, right },
                    })
                }
                SVD::Multiply { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a * b),
                        _ => SVD::Add { left, right },
                    })
                }
                SVD::Subtract { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a - b),
                        _ => SVD::Subtract { left, right },
                    })
                }
                SVD::Divide { divisor, dividend } => {
                    let divisor = divisor.transform_data(constant_folder);
                    let dividend = dividend.transform_data(constant_folder);
                    Some(match (dividend.as_word(), divisor.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a / b),
                        _ => SVD::Divide { dividend, divisor },
                    })
                }
                SVD::SignedDivide { dividend, divisor } => {
                    let divisor = divisor.transform_data(constant_folder);
                    let dividend = dividend.transform_data(constant_folder);
                    Some(match (dividend.as_word(), divisor.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.signed_div(b)),
                        _ => SVD::SignedDivide { dividend, divisor },
                    })
                }
                SVD::Modulo { divisor, dividend } => {
                    let divisor = divisor.transform_data(constant_folder);
                    let dividend = dividend.transform_data(constant_folder);
                    Some(match (dividend.as_word(), divisor.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a % b),
                        _ => SVD::Modulo { dividend, divisor },
                    })
                }
                SVD::SignedModulo { dividend, divisor } => {
                    let divisor = divisor.transform_data(constant_folder);
                    let dividend = dividend.transform_data(constant_folder);
                    Some(match (dividend.as_word(), divisor.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.signed_mod(b)),
                        _ => SVD::SignedDivide { dividend, divisor },
                    })
                }
                SVD::Exp { value, exponent } => {
                    let value = value.transform_data(constant_folder);
                    let exponent = exponent.transform_data(constant_folder);
                    Some(match (value.as_word(), exponent.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.exp(b)),
                        _ => SVD::Exp { value, exponent },
                    })
                }
                SVD::LessThan { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.lt(b)),
                        _ => SVD::LessThan { left, right },
                    })
                }
                SVD::GreaterThan { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.gt(b)),
                        _ => SVD::LessThan { left, right },
                    })
                }
                SVD::SignedLessThan { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.signed_lt(b)),
                        _ => SVD::LessThan { left, right },
                    })
                }
                SVD::SignedGreaterThan { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a.signed_gt(b)),
                        _ => SVD::LessThan { left, right },
                    })
                }
                SVD::Equals { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(KnownWord::from(a == b)),
                        _ => SVD::LessThan { left, right },
                    })
                }
                SVD::IsZero { number } => {
                    let number = number.transform_data(constant_folder);
                    Some(match number.as_word() {
                        Some(a) => SVD::new_known(a.is_zero()),
                        _ => SVD::IsZero { number },
                    })
                }
                SVD::And { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a & b),
                        _ => SVD::And { left, right },
                    })
                }
                SVD::Or { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a | b),
                        _ => SVD::Or { left, right },
                    })
                }
                SVD::Xor { left, right } => {
                    let left = left.transform_data(constant_folder);
                    let right = right.transform_data(constant_folder);
                    Some(match (left.as_word(), right.as_word()) {
                        (Some(a), Some(b)) => SVD::new_known(a ^ b),
                        _ => SVD::Xor { left, right },
                    })
                }
                SVD::Not { value } => {
                    let value = value.transform_data(constant_folder);
                    Some(match value.as_word() {
                        Some(a) => SVD::new_known(!a),
                        _ => SVD::Not { value },
                    })
                }
                SVD::LeftShift { shift, value } => {
                    let shift = shift.transform_data(constant_folder);
                    let value = value.transform_data(constant_folder);
                    Some(match (shift.as_word(), value.as_word()) {
                        (Some(s), Some(v)) => SVD::new_known(v << s),
                        _ => SVD::LeftShift { shift, value },
                    })
                }
                SVD::RightShift { shift, value } => {
                    let shift = shift.transform_data(constant_folder);
                    let value = value.transform_data(constant_folder);
                    Some(match (shift.as_word(), value.as_word()) {
                        (Some(s), Some(v)) => SVD::new_known(v >> s),
                        _ => SVD::RightShift { shift, value },
                    })
                }
                SVD::ArithmeticRightShift { shift, value } => {
                    let shift = shift.transform_data(constant_folder);
                    let value = value.transform_data(constant_folder);
                    Some(match (shift.as_word(), value.as_word()) {
                        (Some(s), Some(v)) => SVD::new_known(v.sar(s)),
                        _ => SVD::RightShift { shift, value },
                    })
                }
                SVD::Concat { values } if values.len() == 1 => values
                    .first()
                    .cloned()
                    .map(|v| v.transform_data(constant_folder).data),
                _ => None,
            }
        }

        self.transform(constant_folder)
    }

    /// Gets the children of the provided node.
    #[allow(clippy::match_same_arms)]
    #[must_use]
    pub fn children(&self) -> Vec<&BoxedVal> {
        match self {
            Self::Value { .. } => vec![],
            Self::KnownData { .. } => vec![],
            Self::Add { left, right } => vec![left, right],
            Self::Multiply { left, right } => vec![left, right],
            Self::Subtract { left, right } => vec![left, right],
            Self::Divide { dividend, divisor } => vec![dividend, divisor],
            Self::SignedDivide { dividend, divisor } => vec![dividend, divisor],
            Self::Modulo { dividend, divisor } => vec![dividend, divisor],
            Self::SignedModulo { dividend, divisor } => vec![dividend, divisor],
            Self::Exp { value, exponent } => vec![value, exponent],
            Self::SignExtend { size, value } => vec![size, value],
            Self::CallWithValue {
                gas,
                address,
                value,
                argument_data,
                ret_offset,
                ret_size,
            } => vec![gas, address, value, argument_data, ret_offset, ret_size],
            Self::CallWithoutValue {
                gas,
                address,
                argument_data,
                ret_offset,
                ret_size,
            } => vec![gas, address, argument_data, ret_offset, ret_size],
            Self::Sha3 { data } => vec![data],
            Self::Address => vec![],
            Self::Balance { address } => vec![address],
            Self::Origin => vec![],
            Self::Caller => vec![],
            Self::CallValue => vec![],
            Self::GasPrice => vec![],
            Self::ExtCodeHash { address } => vec![address],
            Self::BlockHash { block_number } => vec![block_number],
            Self::CoinBase => vec![],
            Self::BlockTimestamp => vec![],
            Self::BlockNumber => vec![],
            Self::Prevrandao => vec![],
            Self::GasLimit => vec![],
            Self::ChainId => vec![],
            Self::SelfBalance => vec![],
            Self::BaseFee => vec![],
            Self::Gas => vec![],
            Self::Log { data, topics } => {
                let mut vec = vec![data];
                vec.extend(topics);
                vec
            }
            Self::Create { value, data } => vec![value, data],
            Self::Create2 { value, data, salt } => vec![value, data, salt],
            Self::SelfDestruct { target } => vec![target],
            Self::LessThan { left, right } => vec![left, right],
            Self::GreaterThan { left, right } => vec![left, right],
            Self::SignedLessThan { left, right } => vec![left, right],
            Self::SignedGreaterThan { left, right } => vec![left, right],
            Self::Equals { left, right } => vec![left, right],
            Self::IsZero { number } => vec![number],
            Self::And { left, right } => vec![left, right],
            Self::Or { left, right } => vec![left, right],
            Self::Xor { left, right } => vec![left, right],
            Self::Not { value } => vec![value],
            Self::LeftShift { shift, value } => vec![shift, value],
            Self::RightShift { shift, value } => vec![shift, value],
            Self::ArithmeticRightShift { shift, value } => vec![shift, value],
            Self::CallData { offset, size, .. } => vec![offset, size],
            Self::CallDataSize => vec![],
            Self::CodeCopy { offset, size } => vec![offset, size],
            Self::ExtCodeSize { address } => vec![address],
            Self::ExtCodeCopy {
                address,
                offset,
                size,
            } => vec![address, offset, size],
            Self::ReturnData { offset, size } => vec![offset, size],
            Self::Return { data } => vec![data],
            Self::Revert { data } => vec![data],
            Self::Condition { value } => vec![value],
            Self::UnwrittenStorageValue { key } => vec![key],
            Self::SLoad { key, value } => vec![key, value],
            Self::StorageSlot { key } => vec![key],
            Self::StorageWrite { key, value } => vec![key, value],
            Self::Concat { values } => values.iter().collect(),
            Self::MappingAccess { slot, key } => vec![slot, key],
            Self::DynamicArrayAccess { slot, index } => vec![slot, index],
            Self::SubWord { value, .. } => vec![value],
            Self::Shifted { value, .. } => vec![value],
            Self::Packed { elements } => elements.iter().map(|e| &e.value).collect(),
        }
    }
}

impl Display for SymbolicValueData {
    #[allow(clippy::too_many_lines)] // No sense in splitting it up
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Value { id } => write!(f, "{id}"),
            Self::KnownData { value } => write!(f, "{value}"),
            Self::Add { left, right } => write!(f, "({left} + {right})"),
            Self::Multiply { left, right } => write!(f, "({left} * {right})"),
            Self::Subtract { left, right } => write!(f, "({left} - {right})"),
            Self::Divide { dividend, divisor } => write!(f, "({dividend} / {divisor})"),
            Self::SignedDivide { dividend, divisor } => write!(f, "({dividend} s/ {divisor})"),
            Self::Modulo { dividend, divisor } => write!(f, "({dividend} % {divisor})"),
            Self::SignedModulo { dividend, divisor } => write!(f, "({dividend} s% {divisor})"),
            Self::Exp { value, exponent } => write!(f, "({value} ** {exponent})"),
            Self::SignExtend { size, value } => write!(f, "sign_ext({size}, {value})"),
            Self::CallWithValue {
                gas,
                address,
                value,
                argument_data,
                ret_offset,
                ret_size,
            } => write!(
                f,
                "call_val({gas}, {address}, {value}, {argument_data}, {ret_offset}, {ret_size})"
            ),
            Self::CallWithoutValue {
                gas,
                address,
                argument_data,
                ret_offset,
                ret_size,
            } => write!(
                f,
                "call_val({gas}, {address}, {argument_data}, {ret_offset}, {ret_size})"
            ),
            Self::Sha3 { data } => write!(f, "sha3({data})"),
            Self::Address => write!(f, "address(this)"),
            Self::Balance { address } => write!(f, "balance({address})"),
            Self::Origin => write!(f, "tx.origin"),
            Self::Caller => write!(f, "msg.sender"),
            Self::CallValue => write!(f, "msg.value"),
            Self::GasPrice => write!(f, "tx.gasprice"),
            Self::ExtCodeHash { address } => write!(f, "ext_code_hash({address})"),
            Self::BlockHash { block_number } => write!(f, "block_hash({block_number}"),
            Self::CoinBase => write!(f, "block.coinbase"),
            Self::BlockTimestamp => write!(f, "block.timestamp"),
            Self::BlockNumber => write!(f, "block.number"),
            Self::Prevrandao => write!(f, "block.prevrandao"),
            Self::GasLimit => write!(f, "block.gaslimit"),
            Self::ChainId => write!(f, "block.chain_id"),
            Self::SelfBalance => write!(f, "address(this).balance"),
            Self::BaseFee => write!(f, "block.basefee"),
            Self::Gas => write!(f, "gasRemaining"),
            Self::Log { data, topics } => write!(f, "log({data}, {topics:?})"),
            Self::Create { value, data } => write!(f, "create({value}, {data})"),
            Self::Create2 { value, data, salt } => write!(f, "create({value}, {data}, {salt})"),
            Self::SelfDestruct { target } => write!(f, "self_destruct({target})"),
            Self::LessThan { left, right } => write!(f, "({left} < {right})"),
            Self::GreaterThan { left, right } => write!(f, "({left} > {right})"),
            Self::SignedLessThan { left, right } => write!(f, "({left} s< {right})"),
            Self::SignedGreaterThan { left, right } => write!(f, "({left} s> {right})"),
            Self::Equals { left, right } => write!(f, "({left} == {right})"),
            Self::IsZero { number } => write!(f, "({number} == 0)"),
            Self::And { left, right } => write!(f, "({left} & {right})"),
            Self::Or { left, right } => write!(f, "({left} | {right})"),
            Self::Xor { left, right } => write!(f, "({left} ^ {right})"),
            Self::Not { value } => write!(f, "!{value}"),
            Self::LeftShift { shift, value } => write!(f, "({value} << {shift})"),
            Self::RightShift { shift, value } => write!(f, "({value} >> {shift})"),
            Self::ArithmeticRightShift { shift, value } => write!(f, "({value} >>> {shift})"),
            Self::CallData { id, offset, size } => write!(f, "call_data[{id}]({offset}, {size})"),
            Self::CallDataSize => write!(f, "call_data_size"),
            Self::CodeCopy { offset, size } => write!(f, "code_copy({offset}, {size})"),
            Self::ExtCodeSize { address } => write!(f, "ext_code_size({address})"),
            Self::ExtCodeCopy {
                address,
                offset,
                size,
            } => write!(f, "ext_code_copy({address}, {offset}, {size})"),
            Self::ReturnData { offset, size } => {
                write!(f, "return_data_copy({offset}, {size})")
            }
            Self::Return { data } => write!(f, "return({data})"),
            Self::Revert { data } => write!(f, "revert({data})"),
            Self::Condition { value } => write!(f, "bool({value})"),
            Self::UnwrittenStorageValue { key } => write!(f, "uninit_storage({key})"),
            Self::SLoad { key, value } => write!(f, "s_load({key}, {value})"),
            Self::StorageSlot { key } => write!(f, "slot<{key}>"),
            Self::StorageWrite { key, value } => write!(f, "s_store({key}, {value})"),
            Self::Concat { values } => {
                write!(f, "concat(")?;
                for (i, value) in values.iter().enumerate() {
                    write!(f, "{value}")?;
                    if i + 1 < values.len() {
                        write!(f, ", ")?;
                    }
                }
                write!(f, ")")
            }
            Self::MappingAccess { slot, key } => write!(f, "mapping_ix<{slot}>[{key}]"),
            Self::DynamicArrayAccess { slot, index } => write!(f, "dynamic_array<{slot}>[{index}]"),
            Self::SubWord {
                value,
                offset,
                size,
            } => write!(f, "sub_word({value}, {offset}, {size})"),
            Self::Shifted { offset, value } => write!(f, "shifted({offset}, {value})"),
            Self::Packed { elements } => {
                write!(f, "packed(")?;
                for (i, value) in elements.iter().enumerate() {
                    write!(f, "{value}")?;
                    if i + 1 < elements.len() {
                        write!(f, ", ")?;
                    }
                }
                write!(f, ")")
            }
        }
    }
}

/// A representation of a span within a packed encoding.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PackedSpan {
    /// The position in the containing word at which the span begins.
    pub offset: usize,

    /// The size of the span within the containing word.
    pub size: usize,

    /// The value of the span.
    pub value: BoxedVal,
}
impl PackedSpan {
    /// Creates a span with a known `size` at `offset` represented by `value`.
    #[must_use]
    pub fn new(offset: usize, size: usize, value: BoxedVal) -> Self {
        Self {
            offset,
            size,
            value,
        }
    }

    /// Transforms the [`Self::value`] within the span with the provided
    /// `transform`.
    ///
    /// This has the same semantics as for [`SymbolicValueData::transform`].
    #[must_use]
    pub fn transform(self, transform: impl Fn(&SVD) -> Option<SVD> + Copy) -> Self {
        let new_data = self.value.transform_data(transform);
        Self {
            offset: self.offset,
            size:   self.size,
            value:  new_data,
        }
    }
}

impl Display for PackedSpan {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "span({}, {}, {})", self.offset, self.size, self.value)
    }
}

/// A descriptor for where a symbolic value originated in the program.
///
/// In essence, these can be thought of as tags that provide more information
/// about the given value when the value is newly and dynamically created.
#[derive(Copy, Clone, Debug, Eq, Hash, Derivative, PartialEq)]
pub enum Provenance {
    /// The value originated from the result of the `CALLDATASIZE` opcode.
    CallDataSize,

    /// The value deposited by the caller.
    CallValue,

    /// The size of the memory at the time the program requested it.
    MSize,

    /// The value originated from the result of the `GAS` opcode.
    Gas,

    /// The value originated in operations performed by the bytecode in the
    /// course of execution.
    Execution,

    /// The value was encoded in the bytecode of the program.
    Bytecode,

    /// The value originated from a read of the current program counter.
    ProgramCounter,

    /// The value originated from the `RETURNDATASIZE` opcode.
    ReturnDataSize,

    /// The value originated from the `SELFBALANCE` opcode.
    SelfBalance,

    /// The value was constructed by the analysis in order to aid the process.
    Synthetic,

    /// The value originated from an `MLOAD` from uninitialized memory.
    UninitializedMemory,

    /// The value originated from an `SLOAD` from uninitialized storage.
    NonWrittenStorage,

    /// The data came from the data returned from a message call.
    MessageCall,

    /// There is no concrete source for this variable.
    Unknown,
}

#[cfg(test)]
mod test {
    use ethnum::U256;
    use uuid::Uuid;

    use crate::vm::value::{known::KnownWord, Provenance, SymbolicValue, SymbolicValueData};

    #[test]
    fn equality_ignores_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(0, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn equality_ignores_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_execution(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn strict_equality_includes_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }

    #[test]
    fn strict_equality_ignores_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_execution(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }

    #[test]
    fn constant_folds_add() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Add { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(8), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_mul() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Multiply { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_sub() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Subtract { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(6), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_div() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Divide { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_signed_div() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedDivide { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_mod() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Modulo { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(1), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_signed_mod() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedModulo { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(1), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_exp() {
        let value = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let exponent = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Exp { value, exponent },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(49), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_less_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::LessThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(true), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_greater_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::GreaterThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_signed_less_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedLessThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(true), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_signed_greater_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedGreaterThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_equals() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Equals { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_is_zero() {
        let number = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::IsZero { number },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_and() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::And { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b0100), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_or() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Or { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b1111), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_xor() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Xor { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b1011), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_not() {
        let value = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(2, SymbolicValueData::Not { value }, Provenance::Synthetic);

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(
                2,
                KnownWord::from_le(!U256::from(1u8)),
                Provenance::Synthetic
            )
        );
    }

    #[test]
    fn constant_folds_left_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::LeftShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b11_1000), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_right_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::RightShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from_le(0b11u32), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_arithmetic_right_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::ArithmeticRightShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b11), Provenance::Synthetic)
        );
    }

    #[test]
    fn constant_folds_deeply() {
        let inner_add_left =
            SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let inner_add_right =
            SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let inner_add = SymbolicValue::new(
            2,
            SymbolicValueData::Add {
                left:  inner_add_left,
                right: inner_add_right,
            },
            Provenance::Synthetic,
        );
        let outer_add_left =
            SymbolicValue::new_known_value(3, KnownWord::from(8), Provenance::Synthetic);
        let outer_add = SymbolicValue::new(
            2,
            SymbolicValueData::Add {
                left:  outer_add_left,
                right: inner_add,
            },
            Provenance::Synthetic,
        );

        let folded = outer_add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(16), Provenance::Synthetic)
        );
    }
}
