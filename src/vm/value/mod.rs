//! This module contains the definition of the [`SymbolicValue`] and its
//! supporting types.

pub mod known;

use std::fmt::{Display, Formatter};

use derivative::Derivative;
use ethnum::{I256, U256};
use uuid::Uuid;

use crate::vm::value::known::KnownWord;

/// A symbolic value is an "execution tree" that records the informative
/// operations that are made to a piece of data. Note that the
/// `instruction_pointer` and `synthetic` flag is ignored for the purposes of
/// equality and hashing.
///
/// # Synthetic Values
///
/// Data is considered to be synthetic when it was generated by the analysis
/// process to more concretely represent an operation.
#[derive(Clone, Debug, Eq, Derivative)]
#[derivative(Hash, PartialEq)]
pub struct SymbolicValue {
    /// The instruction pointer's value at the location where this part of the
    /// symbolic execution tree was recorded.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub instruction_pointer: u32,

    /// Where the data at this level came from.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub provenance: Provenance,

    /// The actual execution tree that forms this value.
    pub data: SymbolicValueData,
}

impl SymbolicValue {
    /// Constructs a new, `SymbolicValue` representing the operation performed
    /// at `instruction_pointer` on the symbolic `data` and with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new(
        instruction_pointer: u32,
        data: SymbolicValueData,
        provenance: Provenance,
    ) -> Box<Self> {
        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Constructs a new `SymbolicValue` representing the operation performed at
    /// `instruction_pointer` on the symbolic `data`. It is created with a
    /// provenance of [`Provenance::Execution`] to indicate that the symbolic
    /// execution of the program created the value.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_from_execution(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Execution)
    }

    /// Constructs a new, synthetic, `SymbolicValue` representing the operation
    /// performed at `instruction_pointer` on the symbolic `data`. It is created
    /// with a provenance of [`Provenance::Synthetic`] to indicate that it was
    /// generated by the analysis process.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_synthetic(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Synthetic)
    }

    /// Constructs a new `SymbolicValue` representing a symbolic value created
    /// at `instruction_pointer` with the provided `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_value(instruction_pointer: u32, provenance: Provenance) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::new_value(),
            provenance,
        )
    }

    /// Constructs a new `SymbolicValue` representing a known value of
    /// `value_data` created at `instruction_pointer` with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_known_value(
        instruction_pointer: u32,
        value_data: KnownWord,
        provenance: Provenance,
    ) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::KnownData { value: value_data },
            provenance,
        )
    }

    /// Compares two symbolic values for strict equality, _including_ the value
    /// of the `instruction_pointer`.
    pub fn strict_eq(&self, other: &Self) -> bool {
        self.instruction_pointer == other.instruction_pointer && self == other
    }

    /// Performs constant folding on immediates wherever possible.
    ///
    /// This means that it will go through the entire value to find any
    /// opportunities where all the operands to a node are
    /// [`SymbolicValueData::KnownData`]s that can be combined statically.
    ///
    /// # Note
    ///
    /// This algorithm is recursive. If it turns out to be a problem in practice
    /// it can be re-written.
    pub fn constant_fold(self) -> BoxedVal {
        let data = self.data.constant_fold();
        let instruction_pointer = self.instruction_pointer;
        let provenance = self.provenance;

        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Checks if the payload is known data.
    pub fn is_known_data(&self) -> bool {
        matches!(self.data, SymbolicValueData::KnownData { .. })
    }

    /// Converts the payload into a VM word if possible.
    pub fn as_word(&self) -> Option<U256> {
        match &self.data {
            SymbolicValueData::KnownData { value } => Some(value.value()),
            _ => None,
        }
    }
}

impl Display for SymbolicValue {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.data)
    }
}

/// The type of a boxed symbolic value.
pub type BoxedVal = Box<SymbolicValue>;

/// The execution tree structures that allow the executor to build traces of the
/// execution pertaining to certain symbolic values.
///
/// Note that these do not duplicate the opcodes 1:1, instead representing the
/// opcode operations that _provide information about the type of a value_ as an
/// execution tree. Notable (and intentional) omissions here are the opcodes
/// that deal with memory, storage, and the stack.
///
/// # Semantics
///
/// For the semantics of these operations at runtime, please see the
/// corresponding documentation comments in the [`crate::opcode`] subtree.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum SymbolicValueData {
    /// A value with identity, but about which nothing else is known.
    Value { id: Uuid },

    /// A value that has is made up of a known sequence of bytes.
    KnownData { value: KnownWord },

    /// Addition of symbolic values.
    Add { left: BoxedVal, right: BoxedVal },

    /// Multiplication of symbolic values.
    Multiply { left: BoxedVal, right: BoxedVal },

    /// Subtraction of symbolic values.
    Subtract { left: BoxedVal, right: BoxedVal },

    /// Division of symbolic values.
    Divide { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed division of symbolic values.
    SignedDivide { dividend: BoxedVal, divisor: BoxedVal },

    /// Modulo of symbolic values.
    Modulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed modulo of symbolic values.
    SignedModulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Exponentiation of symbolic values.
    Exp { value: BoxedVal, exponent: BoxedVal },

    /// Sign extension of a symbolic value to a symbolic length.
    SignExtend { size: BoxedVal, value: BoxedVal },

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the return data in the opcode, as we know nothing
    /// about what the call will do with the argument. Internal execution will
    /// read from memory directly, so we pick up the returned value there.
    CallWithValue {
        gas:           BoxedVal,
        address:       BoxedVal,
        value:         BoxedVal,
        argument_data: BoxedVal,
        ret_offset:    BoxedVal,
        ret_size:      BoxedVal,
    },

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the return data in the opcode, as we know nothing
    /// about what the call will do with the argument. Internal execution will
    /// read from memory directly, so we pick up the returned value there.
    CallWithoutValue {
        gas:           BoxedVal,
        address:       BoxedVal,
        argument_data: BoxedVal,
        ret_offset:    BoxedVal,
        ret_size:      BoxedVal,
    },

    /// A keccak256 hash on symbolic values.
    Sha3 { data: BoxedVal },

    /// The address of the currently-executing contract.
    Address,

    /// The balance of the target account.
    Balance { address: BoxedVal },

    /// The address of the transaction's origin.
    Origin,

    /// The caller of the transaction.
    Caller,

    /// The value deposited by the caller.
    CallValue,

    /// The current gas price.
    GasPrice,

    /// Compute the external code hash of a symbolic value.
    ExtCodeHash { address: BoxedVal },

    /// Gets the block hash from one of the
    BlockHash { block_number: BoxedVal },

    /// Gets the block's beneficiary address.
    CoinBase,

    /// Gets the timestamp of the current block.
    BlockTimestamp,

    /// Gets the number of the current block.
    BlockNumber,

    /// Gets the difficulty of the current block.
    Prevrandao,

    /// Gets the gas limit of  the current block.
    GasLimit,

    /// Gets the identifier for the chain on which the current block is
    /// executing.
    ChainId,

    /// Gets the balance of the currently executing account.
    SelfBalance,

    /// Gets the block base fee.
    BaseFee,

    /// Gets the currently available gas.
    Gas,

    /// Logs the `value` from memory of `size` with the provided `topics`.
    Log { data: BoxedVal, topics: Vec<BoxedVal> },

    /// Creates a new contract.
    Create { value: BoxedVal, data: BoxedVal },

    /// Creates a new contract at a predictable address.
    Create2 { value: BoxedVal, salt: BoxedVal, data: BoxedVal },

    /// Registers the account for deletion.
    SelfDestruct { target: BoxedVal },

    /// Less than for symbolic values.
    LessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values.
    GreaterThan { left: BoxedVal, right: BoxedVal },

    /// Less than for symbolic values where the values are signed.
    SignedLessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values where the values are signed.
    SignedGreaterThan { left: BoxedVal, right: BoxedVal },

    /// Equality for symbolic values.
    Equals { left: BoxedVal, right: BoxedVal },

    /// Checking if a symbolic value is zero.
    IsZero { number: BoxedVal },

    /// Logical conjunction for symbolic values.
    And { left: BoxedVal, right: BoxedVal },

    /// Logical disjunction for symbolic values.
    Or { left: BoxedVal, right: BoxedVal },

    /// XOR for symbolic values.
    Xor { left: BoxedVal, right: BoxedVal },

    /// Negation of a symbolic value.
    Not { bool: BoxedVal },

    /// Left shift with symbolic values.
    LeftShift { shift: BoxedVal, value: BoxedVal },

    /// Right shift with symbolic values.
    RightShift { shift: BoxedVal, value: BoxedVal },

    /// Signed right shift with symbolic values.
    ArithmeticRightShift { shift: BoxedVal, value: BoxedVal },

    /// Loading the data at `offset` for `size` in the call data.
    CallData { offset: BoxedVal, size: BoxedVal },

    /// The size of the current call data.
    CallDataSize,

    /// Data copied from the code of the current contract starting at `offset`
    /// for `size`.
    CodeCopy { offset: BoxedVal, size: BoxedVal },

    /// Gets the code size of the target contract.
    ExtCodeSize { address: BoxedVal },

    /// Data copied from the code of the contract at `address` starting at
    /// `offset` for `size`.
    ExtCodeCopy { address: BoxedVal, offset: BoxedVal, size: BoxedVal },

    /// Data copied from the return data from the previous call at `offset` for
    /// `size`.
    ReturnData { offset: BoxedVal, size: BoxedVal },

    /// The return. Does not stay on the stack but is stored nevertheless.
    Return { data: BoxedVal },

    /// The revert. Does not stay on the stack but is stored nevertheless.
    Revert { data: BoxedVal },

    /// A value that was used as the input to a conditional.
    Condition { value: BoxedVal },

    /// A value representing the return from a storage load at `key`.
    SLoad { key: BoxedVal },

    /// The concatenation of multiple values.
    Concat { values: Vec<BoxedVal> },
}

impl SymbolicValueData {
    /// Constructs a new [`Self::KnownData`] containing the data `value`.
    pub fn new_known(value: KnownWord) -> Self {
        SymbolicValueData::KnownData { value }
    }

    /// Constructs a new [`Self::KnownData`] wrapping `value`.
    fn known_from(value: U256) -> Self {
        Self::KnownData {
            value: value.into(),
        }
    }

    /// Constructs a new [`Self::Value`] about which only its existence and
    /// identity are known.
    pub fn new_value() -> Self {
        let id = Uuid::new_v4();
        SymbolicValueData::Value { id }
    }

    /// Performs constant folding on immediates wherever possible.
    ///
    /// This means that it will go through the entire value to find any
    /// opportunities where all the operands to a node are [`Self::KnownData`]s
    /// that can be combined statically.
    ///
    /// # Note
    ///
    /// This algorithm is recursive. If it turns out to be a problem in practice
    /// it can be re-written.
    pub fn constant_fold(self) -> Self {
        match self {
            Self::Value { .. } => self,
            Self::KnownData { .. } => self,
            Self::Add { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a + b),
                    _ => Self::Add { left, right },
                }
            }
            Self::Multiply { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a * b),
                    _ => Self::Add { left, right },
                }
            }
            Self::Subtract { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a - b),
                    _ => Self::Subtract { left, right },
                }
            }
            Self::Divide { divisor, dividend } => {
                let divisor = divisor.constant_fold();
                let dividend = dividend.constant_fold();
                match (dividend.as_word(), divisor.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a / b),
                    _ => Self::Divide { dividend, divisor },
                }
            }
            Self::SignedDivide { dividend, divisor } => {
                let divisor = divisor.constant_fold();
                let dividend = dividend.constant_fold();
                match (dividend.as_word(), divisor.as_word()) {
                    (Some(a), Some(b)) => {
                        let a_signed = I256::from_le_bytes(a.to_le_bytes());
                        let b_signed = I256::from_le_bytes(b.to_le_bytes());
                        let result = a_signed / b_signed;
                        Self::known_from(U256::from_le_bytes(result.to_le_bytes()))
                    }
                    _ => Self::SignedDivide { dividend, divisor },
                }
            }
            Self::Modulo { divisor, dividend } => {
                let divisor = divisor.constant_fold();
                let dividend = dividend.constant_fold();
                match (dividend.as_word(), divisor.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a % b),
                    _ => Self::Modulo { dividend, divisor },
                }
            }
            Self::SignedModulo { dividend, divisor } => {
                let divisor = divisor.constant_fold();
                let dividend = dividend.constant_fold();
                match (dividend.as_word(), divisor.as_word()) {
                    (Some(a), Some(b)) => {
                        let a_signed = I256::from_le_bytes(a.to_le_bytes());
                        let b_signed = I256::from_le_bytes(b.to_le_bytes());
                        let result = a_signed % b_signed;
                        Self::known_from(U256::from_le_bytes(result.to_le_bytes()))
                    }
                    _ => Self::SignedModulo { dividend, divisor },
                }
            }
            Self::Exp { value, exponent } => {
                let value = value.constant_fold();
                let exponent = exponent.constant_fold();
                match (value.as_word(), exponent.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a.pow(b.as_u32())),
                    _ => Self::Exp { value, exponent },
                }
            }
            Self::SignExtend { size, value } => Self::SignExtend {
                size:  size.constant_fold(),
                value: value.constant_fold(),
            },
            Self::CallWithValue {
                gas,
                address,
                value,
                argument_data,
                ret_offset,
                ret_size,
            } => Self::CallWithValue {
                gas:           gas.constant_fold(),
                address:       address.constant_fold(),
                value:         value.constant_fold(),
                argument_data: argument_data.constant_fold(),
                ret_offset:    ret_offset.constant_fold(),
                ret_size:      ret_size.constant_fold(),
            },
            Self::CallWithoutValue {
                gas,
                address,
                argument_data,
                ret_offset,
                ret_size,
            } => Self::CallWithoutValue {
                gas:           gas.constant_fold(),
                address:       address.constant_fold(),
                argument_data: argument_data.constant_fold(),
                ret_offset:    ret_offset.constant_fold(),
                ret_size:      ret_size.constant_fold(),
            },
            Self::Sha3 { data } => Self::Sha3 {
                data: data.constant_fold(),
            },
            Self::Address => self,
            Self::Balance { address } => Self::Balance {
                address: address.constant_fold(),
            },
            Self::Origin => self,
            Self::Caller => self,
            Self::CallValue => self,
            Self::GasPrice => self,
            Self::ExtCodeHash { address } => Self::ExtCodeHash {
                address: address.constant_fold(),
            },
            Self::BlockHash { block_number } => Self::BlockHash {
                block_number: block_number.constant_fold(),
            },
            Self::CoinBase => self,
            Self::BlockTimestamp => self,
            Self::BlockNumber => self,
            Self::Prevrandao => self,
            Self::GasLimit => self,
            Self::ChainId => self,
            Self::SelfBalance => self,
            Self::BaseFee => self,
            Self::Gas => self,
            Self::Log { data, topics } => Self::Log {
                data:   data.constant_fold(),
                topics: topics.into_iter().map(|t| t.constant_fold()).collect(),
            },
            Self::Create { value, data } => Self::Create {
                value: value.constant_fold(),
                data:  data.constant_fold(),
            },
            Self::Create2 { value, data, salt } => Self::Create2 {
                value: value.constant_fold(),
                data:  data.constant_fold(),
                salt:  salt.constant_fold(),
            },
            Self::SelfDestruct { target } => Self::SelfDestruct {
                target: target.constant_fold(),
            },
            Self::LessThan { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::new_known(KnownWord::from(a < b)),
                    _ => Self::LessThan { left, right },
                }
            }
            Self::GreaterThan { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::new_known(KnownWord::from(a > b)),
                    _ => Self::LessThan { left, right },
                }
            }
            Self::SignedLessThan { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::new_known(KnownWord::from(
                        I256::from_le_bytes(a.to_le_bytes()) < I256::from_le_bytes(b.to_le_bytes()),
                    )),
                    _ => Self::LessThan { left, right },
                }
            }
            Self::SignedGreaterThan { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::new_known(KnownWord::from(
                        I256::from_le_bytes(a.to_le_bytes()) > I256::from_le_bytes(b.to_le_bytes()),
                    )),
                    _ => Self::LessThan { left, right },
                }
            }
            Self::Equals { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::new_known(KnownWord::from(a == b)),
                    _ => Self::LessThan { left, right },
                }
            }
            Self::IsZero { number } => {
                let number = number.constant_fold();
                match number.as_word() {
                    Some(a) => Self::new_known(KnownWord::from(a == U256::from(0u8))),
                    _ => Self::IsZero { number },
                }
            }
            Self::And { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a & b),
                    _ => Self::And { left, right },
                }
            }
            Self::Or { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a | b),
                    _ => Self::Or { left, right },
                }
            }
            Self::Xor { left, right } => {
                let left = left.constant_fold();
                let right = right.constant_fold();
                match (left.as_word(), right.as_word()) {
                    (Some(a), Some(b)) => Self::known_from(a ^ b),
                    _ => Self::Xor { left, right },
                }
            }
            Self::Not { bool } => {
                let bool = bool.constant_fold();
                match bool.as_word() {
                    Some(a) => Self::known_from(!a),
                    _ => Self::Not { bool },
                }
            }
            Self::LeftShift { shift, value } => {
                let shift = shift.constant_fold();
                let value = value.constant_fold();
                match (shift.as_word(), value.as_word()) {
                    (Some(s), Some(v)) => Self::known_from(v << s),
                    _ => Self::LeftShift { shift, value },
                }
            }
            Self::RightShift { shift, value } => {
                let shift = shift.constant_fold();
                let value = value.constant_fold();
                match (shift.as_word(), value.as_word()) {
                    (Some(s), Some(v)) => Self::known_from(v >> s),
                    _ => Self::RightShift { shift, value },
                }
            }
            Self::ArithmeticRightShift { shift, value } => {
                let shift = shift.constant_fold();
                let value = value.constant_fold();
                match (shift.as_word(), value.as_word()) {
                    (Some(s), Some(v)) => Self::known_from(v >> s),
                    _ => Self::RightShift { shift, value },
                }
            }
            Self::CallData { offset, size } => Self::CallData {
                offset: offset.constant_fold(),
                size:   size.constant_fold(),
            },
            Self::CallDataSize => self,
            Self::CodeCopy { offset, size } => Self::CodeCopy {
                offset: offset.constant_fold(),
                size:   size.constant_fold(),
            },
            Self::ExtCodeSize { address } => Self::ExtCodeSize {
                address: address.constant_fold(),
            },
            Self::ExtCodeCopy {
                address,
                offset,
                size,
            } => Self::ExtCodeCopy {
                address: address.constant_fold(),
                offset:  offset.constant_fold(),
                size:    size.constant_fold(),
            },
            Self::ReturnData { offset, size } => Self::ReturnData {
                offset: offset.constant_fold(),
                size:   size.constant_fold(),
            },
            Self::Return { data } => Self::Return {
                data: data.constant_fold(),
            },
            Self::Revert { data } => Self::Revert {
                data: data.constant_fold(),
            },
            Self::Condition { value } => Self::Condition {
                value: value.constant_fold(),
            },
            Self::SLoad { key } => Self::SLoad {
                key: key.constant_fold(),
            },
            Self::Concat { values } => Self::Concat {
                values: values.into_iter().map(|v| v.constant_fold()).collect(),
            },
        }
    }
}

impl Display for SymbolicValueData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Value { id } => write!(f, "{id}"),
            Self::KnownData { value } => write!(f, "{value}"),
            Self::Add { left, right } => write!(f, "({left} + {right})"),
            Self::Multiply { left, right } => write!(f, "({left} * {right})"),
            Self::Subtract { left, right } => write!(f, "({left} - {right})"),
            Self::Divide { dividend, divisor } => write!(f, "({dividend} / {divisor})"),
            Self::SignedDivide { dividend, divisor } => write!(f, "({dividend} s/ {divisor})"),
            Self::Modulo { dividend, divisor } => write!(f, "({dividend} % {divisor})"),
            Self::SignedModulo { dividend, divisor } => write!(f, "({dividend} s% {divisor})"),
            Self::Exp { value, exponent } => write!(f, "({value} ** {exponent})"),
            Self::SignExtend { size, value } => write!(f, "sign_ext({size}, {value})"),
            Self::CallWithValue {
                gas,
                address,
                value,
                argument_data,
                ret_offset,
                ret_size,
            } => write!(
                f,
                "call_val({gas}, {address}, {value}, {argument_data}, {ret_offset}, {ret_size})"
            ),
            Self::CallWithoutValue {
                gas,
                address,
                argument_data,
                ret_offset,
                ret_size,
            } => write!(
                f,
                "call_val({gas}, {address}, {argument_data}, {ret_offset}, {ret_size})"
            ),
            Self::Sha3 { data } => write!(f, "sha3({data})"),
            Self::Address => write!(f, "address(this)"),
            Self::Balance { address } => write!(f, "balance({address})"),
            Self::Origin => write!(f, "tx.origin"),
            Self::Caller => write!(f, "msg.sender"),
            Self::CallValue => write!(f, "msg.value"),
            Self::GasPrice => write!(f, "tx.gasprice"),
            Self::ExtCodeHash { address } => write!(f, "ext_code_hash({address})"),
            Self::BlockHash { block_number } => write!(f, "block_hash({block_number}"),
            Self::CoinBase => write!(f, "block.coinbase"),
            Self::BlockTimestamp => write!(f, "block.timestamp"),
            Self::BlockNumber => write!(f, "block.number"),
            Self::Prevrandao => write!(f, "block.prevrandao"),
            Self::GasLimit => write!(f, "block.gaslimit"),
            Self::ChainId => write!(f, "block.chain_id"),
            Self::SelfBalance => write!(f, "address(this).balance"),
            Self::BaseFee => write!(f, "block.basefee"),
            Self::Gas => write!(f, "gasRemaining"),
            Self::Log { data, topics } => write!(f, "log({data}, {topics:?})"),
            Self::Create { value, data } => write!(f, "create({value}, {data})"),
            Self::Create2 { value, data, salt } => write!(f, "create({value}, {data}, {salt})"),
            Self::SelfDestruct { target } => write!(f, "self_destruct({target})"),
            Self::LessThan { left, right } => write!(f, "({left} < {right})"),
            Self::GreaterThan { left, right } => write!(f, "({left} > {right})"),
            Self::SignedLessThan { left, right } => write!(f, "({left} s< {right})"),
            Self::SignedGreaterThan { left, right } => write!(f, "({left} s> {right})"),
            Self::Equals { left, right } => write!(f, "({left} == {right})"),
            Self::IsZero { number } => write!(f, "({number} == 0)"),
            Self::And { left, right } => write!(f, "({left} & {right})"),
            Self::Or { left, right } => write!(f, "({left} | {right})"),
            Self::Xor { left, right } => write!(f, "({left} ^ {right})"),
            Self::Not { bool } => write!(f, "!{bool}"),
            Self::LeftShift { shift, value } => write!(f, "({value} << {shift})"),
            Self::RightShift { shift, value } => write!(f, "({value} >> {shift})"),
            Self::ArithmeticRightShift { shift, value } => write!(f, "({value} >>> {shift})"),
            Self::CallData { offset, size } => write!(f, "call_data({offset}, {size})"),
            Self::CallDataSize => write!(f, "call_data_size"),
            Self::CodeCopy { offset, size } => write!(f, "code_copy({offset}, {size})"),
            Self::ExtCodeSize { address } => write!(f, "ext_code_size({address})"),
            Self::ExtCodeCopy {
                address,
                offset,
                size,
            } => write!(f, "ext_code_copy({address}, {offset}, {size})"),
            Self::ReturnData { offset, size } => {
                write!(f, "return_data_copy({offset}, {size})")
            }
            Self::Return { data } => write!(f, "return({data})"),
            Self::Revert { data } => write!(f, "revert({data})"),
            Self::Condition { value } => write!(f, "bool({value})"),
            Self::SLoad { key } => write!(f, "s_load({key})"),
            Self::Concat { values } => {
                write!(f, "concat(")?;
                for (i, value) in values.iter().enumerate() {
                    write!(f, "{value}")?;
                    if i + 1 < values.len() {
                        write!(f, ", ")?;
                    }
                }
                write!(f, ")")
            }
        }
    }
}

/// A descriptor for where a symbolic value originated in the program.
///
/// In essence, these can be thought of as tags that provide more information
/// about the given value when the value is newly and dynamically created.
#[derive(Clone, Debug, Eq, Hash, Derivative, PartialEq)]
pub enum Provenance {
    /// The value originated from the result of the `CALLDATASIZE` opcode.
    CallDataSize,

    /// The value deposited by the caller.
    CallValue,

    /// The size of the memory at the time the program requested it.
    MSize,

    /// The value originated from the result of the `GAS` opcode.
    Gas,

    /// The value originated in operations performed by the bytecode in the
    /// course of execution.
    Execution,

    /// The value was encoded in the bytecode of the program.
    Bytecode,

    /// The value originated from a read of the current program counter.
    ProgramCounter,

    /// The value originated from the `RETURNDATASIZE` opcode.
    ReturnDataSize,

    /// The value originated from the `SELFBALANCE` opcode.
    SelfBalance,

    /// The value was constructed by the analysis in order to aid the process.
    Synthetic,

    /// The value originated from an `MLOAD` from uninitialized memory.
    UninitializedMemory,

    /// The value originated from an `SLOAD` from uninitialized storage.
    NonWrittenStorage,

    /// The data came from the data returned from a message call.
    MessageCall,

    /// There is no concrete source for this variable.
    Unknown,
}

#[cfg(test)]
mod test {
    use ethnum::U256;
    use uuid::Uuid;

    use crate::vm::value::{known::KnownWord, Provenance, SymbolicValue, SymbolicValueData};

    #[test]
    fn equality_ignores_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(0, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn equality_ignores_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_execution(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn strict_equality_includes_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }

    #[test]
    fn strict_equality_ignores_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_execution(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }

    #[test]
    fn constant_folds_add() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Add { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(8), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_mul() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Multiply { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_sub() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Subtract { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(6), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_div() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Divide { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_signed_div() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedDivide { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(7), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_mod() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Modulo { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(1), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_signed_mod() {
        let dividend = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let divisor = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedModulo { dividend, divisor },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(1), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_exp() {
        let value = SymbolicValue::new_known_value(0, KnownWord::from(7), Provenance::Synthetic);
        let exponent = SymbolicValue::new_known_value(1, KnownWord::from(2), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Exp { value, exponent },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(49), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_less_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::LessThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(true), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_greater_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::GreaterThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_signed_less_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedLessThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(true), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_signed_greater_than() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::SignedGreaterThan { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_equals() {
        let left = SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let right = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Equals { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_is_zero() {
        let number = SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::IsZero { number },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(false), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_and() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::And { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b0100), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_or() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Or { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b1111), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_xor() {
        let left =
            SymbolicValue::new_known_value(0, KnownWord::from(0b0101), Provenance::Synthetic);
        let right =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::Xor { left, right },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b1011), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_not() {
        let bool = SymbolicValue::new_known_value(1, KnownWord::from(1), Provenance::Synthetic);
        let add = SymbolicValue::new(2, SymbolicValueData::Not { bool }, Provenance::Synthetic);

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(
                2,
                KnownWord::from(!U256::from(1u8)),
                Provenance::Synthetic
            )
        )
    }

    #[test]
    fn constant_folds_left_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::LeftShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b111000), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_right_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::RightShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b11), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_arithmetic_right_shift() {
        let shift = SymbolicValue::new_known_value(0, KnownWord::from(2), Provenance::Synthetic);
        let value =
            SymbolicValue::new_known_value(1, KnownWord::from(0b1110), Provenance::Synthetic);
        let add = SymbolicValue::new(
            2,
            SymbolicValueData::ArithmeticRightShift { shift, value },
            Provenance::Synthetic,
        );

        let folded = add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(0b11), Provenance::Synthetic)
        )
    }

    #[test]
    fn constant_folds_deeply() {
        let inner_add_left =
            SymbolicValue::new_known_value(0, KnownWord::from(1), Provenance::Synthetic);
        let inner_add_right =
            SymbolicValue::new_known_value(1, KnownWord::from(7), Provenance::Synthetic);
        let inner_add = SymbolicValue::new(
            2,
            SymbolicValueData::Add {
                left:  inner_add_left,
                right: inner_add_right,
            },
            Provenance::Synthetic,
        );
        let outer_add_left =
            SymbolicValue::new_known_value(3, KnownWord::from(8), Provenance::Synthetic);
        let outer_add = SymbolicValue::new(
            2,
            SymbolicValueData::Add {
                left:  outer_add_left,
                right: inner_add,
            },
            Provenance::Synthetic,
        );

        let folded = outer_add.constant_fold();

        assert_eq!(
            folded,
            SymbolicValue::new_known_value(2, KnownWord::from(16), Provenance::Synthetic)
        )
    }
}
