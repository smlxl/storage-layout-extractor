//! This module contains the definition of the [`SymbolicValue`] and its
//! supporting types.

pub mod known_data;

use derivative::Derivative;
use uuid::Uuid;

use crate::vm::value::known_data::KnownData;

/// A symbolic value is an "execution tree" that records the informative
/// operations that are made to a piece of data. Note that the
/// `instruction_pointer` and `synthetic` flag is ignored for the purposes of
/// equality and hashing.
///
/// # Synthetic Values
///
/// Data is considered to be synthetic when it was generated by the analysis
/// process to more concretely represent an operation.
#[derive(Clone, Debug, Eq, Derivative)]
#[derivative(Hash, PartialEq)]
pub struct SymbolicValue {
    /// The instruction pointer's value at the location where this part of the
    /// symbolic execution tree was recorded.
    #[derivative(PartialEq = "ignore", Hash = "ignore")]
    pub instruction_pointer: u32,

    /// Where the data at this level came from.
    pub provenance: Provenance,

    /// The actual execution tree that forms this value.
    pub data: SymbolicValueData,
}

impl SymbolicValue {
    /// Constructs a new, `SymbolicValue` representing the operation performed
    /// at `instruction_pointer` on the symbolic `data` and with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new(
        instruction_pointer: u32,
        data: SymbolicValueData,
        provenance: Provenance,
    ) -> Box<Self> {
        Box::new(Self {
            instruction_pointer,
            provenance,
            data,
        })
    }

    /// Constructs a new `SymbolicValue` representing the operation performed at
    /// `instruction_pointer` on the symbolic `data`. It is created with a
    /// provenance of [`Provenance::Execution`] to indicate that the symbolic
    /// execution of the program created the value.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_from_execution(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Execution)
    }

    /// Constructs a new, synthetic, `SymbolicValue` representing the operation
    /// performed at `instruction_pointer` on the symbolic `data`. It is created
    /// with a provenance of [`Provenance::Synthetic`] to indicate that it was
    /// generated by the analysis process.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_synthetic(instruction_pointer: u32, data: SymbolicValueData) -> Box<Self> {
        Self::new(instruction_pointer, data, Provenance::Synthetic)
    }

    /// Constructs a new `SymbolicValue` representing a symbolic value created
    /// at `instruction_pointer` with the provided `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_value(instruction_pointer: u32, provenance: Provenance) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::new_value(),
            provenance,
        )
    }

    /// Constructs a new `SymbolicValue` representing a known value of
    /// `value_data` created at `instruction_pointer` with the specified
    /// `provenance`.
    ///
    /// It returns [`Box<Self>`] as in the vast majority of cases this type is
    /// used in a recursive data type and hence indirection is needed.
    pub fn new_known_value(
        instruction_pointer: u32,
        value_data: KnownData,
        provenance: Provenance,
    ) -> Box<Self> {
        Self::new(
            instruction_pointer,
            SymbolicValueData::KnownData {
                id:    Uuid::new_v4(),
                value: value_data,
            },
            provenance,
        )
    }

    /// Compares two symbolic values for strict equality, _including_ the value
    /// of the `instruction_pointer`.
    pub fn strict_eq(&self, other: &Self) -> bool {
        self.instruction_pointer == other.instruction_pointer && self == other
    }
}

/// The type of a boxed symbolic value.
pub type BoxedVal = Box<SymbolicValue>;

/// The execution tree structures that allow the executor to build traces of the
/// execution pertaining to certain symbolic values.
///
/// Note that these do not duplicate the opcodes 1:1, instead representing the
/// opcode operations that _provide information about the type of a value_ as an
/// execution tree. Notable (and intentional) omissions here are the opcodes
/// that deal with memory, storage, and the stack.
///
/// # Semantics
///
/// For the semantics of these operations at runtime, please see the
/// corresponding documentation comments in the [`crate::opcode`] subtree.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum SymbolicValueData {
    /// A value with identity, but about which nothing else is known.
    Value { id: Uuid },

    /// A value that has is made up of a known sequence of bytes.
    ///
    /// It has an `id` in order to allow the program to distinguish the same
    /// value created in different places.
    KnownData { id: Uuid, value: KnownData },

    /// Addition of symbolic values.
    Add { left: BoxedVal, right: BoxedVal },

    /// Multiplication of symbolic values.
    Multiply { left: BoxedVal, right: BoxedVal },

    /// Subtraction of symbolic values.
    Subtract { left: BoxedVal, right: BoxedVal },

    /// Division of symbolic values.
    Divide { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed division of symbolic values.
    SignedDivide { dividend: BoxedVal, divisor: BoxedVal },

    /// Modulo of symbolic values.
    Modulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Signed modulo of symbolic values.
    SignedModulo { dividend: BoxedVal, divisor: BoxedVal },

    /// Exponentiation of symbolic values.
    Exp { value: BoxedVal, exponent: BoxedVal },

    /// Sign extension of a symbolic value to a symbolic length.
    SignExtend { size: BoxedVal, value: BoxedVal },

    /// Program counter.
    ProgramCounter,

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the argument data or return data in the opcode, as
    /// we know nothing about what the call will do with the argument. Internal
    /// execution will read from memory directly, so we pick up the returned
    /// value there.
    CallWithValue {
        gas:      BoxedVal,
        address:  BoxedVal,
        value:    BoxedVal,
        arg_size: BoxedVal,
        ret_size: BoxedVal,
    },

    /// A message call that passes a value.
    ///
    /// We explicitly _do not care_ about the specific kind of call here, as it
    /// makes no difference to the kind of information we get.
    ///
    /// We also do not store the argument data or return data in the opcode, as
    /// we know nothing about what the call will do with the argument. Internal
    /// execution will read from memory directly, so we pick up the returned
    /// value there.
    CallWithoutValue {
        gas:      BoxedVal,
        address:  BoxedVal,
        arg_size: BoxedVal,
        ret_size: BoxedVal,
    },

    /// A keccak256 hash on symbolic values.
    Sha3 { value: BoxedVal, offset: BoxedVal, size: BoxedVal },

    /// The address of the currently-executing contract.
    Address,

    /// The balance of the target account.
    Balance { address: BoxedVal },

    /// The address of the transaction's origin.
    Origin,

    /// The caller of the transaction.
    Caller,

    /// The value deposited by the caller.
    CallValue,

    /// The current gas price.
    GasPrice,

    /// Compute the external code hash of a symbolic value.
    ExtCodeHash { address: BoxedVal },

    /// Gets the block hash from one of the
    BlockHash { block_number: BoxedVal },

    /// Gets the block's beneficiary address.
    CoinBase,

    /// Gets the timestamp of the current block.
    BlockTimestamp,

    /// Gets the number of the current block.
    BlockNumber,

    /// Gets the difficulty of the current block.
    Prevrandao,

    /// Gets the gas limit of  the current block.
    GasLimit,

    /// Gets the identifier for the chain on which the current block is
    /// executing.
    ChainId,

    /// Gets the balance of the currently executing account.
    SelfBalance,

    /// Gets the block base fee.
    BaseFee,

    /// Gets the currently available gas.
    Gas,

    /// Logs the `value` from memory of `size` with the provided `topics`.
    Log { value: BoxedVal, size: BoxedVal, topics: Vec<BoxedVal> },

    /// Creates a new contract.
    Create {
        value:  BoxedVal,
        offset: BoxedVal,
        size:   BoxedVal,
        data:   BoxedVal,
    },

    /// Creates a new contract at a predictable address.
    Create2 {
        value:  BoxedVal,
        offset: BoxedVal,
        size:   BoxedVal,
        salt:   BoxedVal,
        data:   BoxedVal,
    },

    /// Registers the account for deletion.
    SelfDestruct { target: BoxedVal },

    /// Less than for symbolic values.
    LessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values.
    GreaterThan { left: BoxedVal, right: BoxedVal },

    /// Less than for symbolic values where the values are signed.
    SignedLessThan { left: BoxedVal, right: BoxedVal },

    /// Greater than for symbolic values where the values are signed.
    SignedGreaterThan { left: BoxedVal, right: BoxedVal },

    /// Equality for symbolic values.
    Equals { left: BoxedVal, right: BoxedVal },

    /// Checking if a symbolic value is zero.
    IsZero { number: BoxedVal },

    /// Logical conjunction for symbolic values.
    And { left: BoxedVal, right: BoxedVal },

    /// Logical disjunction for symbolic values.
    Or { left: BoxedVal, right: BoxedVal },

    /// XOR for symbolic values.
    Xor { left: BoxedVal, right: BoxedVal },

    /// Negation of a symbolic value.
    Not { bool: BoxedVal },

    /// Left shift with symbolic values.
    LeftShift { shift: BoxedVal, value: BoxedVal },

    /// Right shift with symbolic values.
    RightShift { shift: BoxedVal, value: BoxedVal },

    /// Signed right shift with symbolic values.
    ArithmeticRightShift { shift: BoxedVal, value: BoxedVal },

    /// Loading the data at `offset` for `size` in the call data.
    CallData { offset: BoxedVal, size: BoxedVal },

    /// The size of the current call data.
    CallDataSize,

    /// Data copied from the code of the current contract starting at `offset`
    /// for `size`.
    CodeCopy { offset: BoxedVal, size: BoxedVal },

    /// Gets the code size of the target contract.
    ExtCodeSize { address: BoxedVal },

    /// Data copied from the code of the contract at `address` starting at
    /// `offset` for `size`.
    ExtCodeCopy { address: BoxedVal, offset: BoxedVal, size: BoxedVal },

    /// Data copied from the return data from the previous call at `offset` for
    /// `size`.
    ReturnDataCopy { offset: BoxedVal, size: BoxedVal },

    /// The return. Does not stay on the stack but is stored nevertheless.
    Return { offset: BoxedVal, size: BoxedVal },

    /// The revert. Does not stay on the stack but is stored nevertheless.
    Revert { offset: BoxedVal, size: BoxedVal },

    /// A value that was used as the input to a conditional.
    Condition { value: BoxedVal },
}

impl SymbolicValueData {
    /// Constructs a new [`Self::KnownData`] containing the data `value`.
    pub fn new_known(value: KnownData) -> Self {
        let id = Uuid::new_v4();
        SymbolicValueData::KnownData { id, value }
    }

    /// Constructs a new [`Self::Value`] about which only its existence and
    /// identity are known.
    pub fn new_value() -> Self {
        let id = Uuid::new_v4();
        SymbolicValueData::Value { id }
    }
}

/// A descriptor for where a symbolic value originated in the program.
///
/// In essence, these can be thought of as tags that provide more information
/// about the given value when the value is newly and dynamically created.
#[derive(Clone, Debug, Eq, Hash, Derivative, PartialEq)]
pub enum Provenance {
    /// The value originated from the result of the `CALLDATASIZE` opcode.
    CallDataSize,

    /// The value deposited by the caller.
    CallValue,

    /// The size of the memory at the time the program requested it.
    MSize,

    /// The value originated from the result of the `GAS` opcode.
    Gas,

    /// The value originated in operations performed by the bytecode in the
    /// course of execution.
    Execution,

    /// The value was encoded in the bytecode of the program.
    Bytecode,

    /// The value originated from a read of the current program counter.
    ProgramCounter,

    /// The value originated from the `RETURNDATASIZE` opcode.
    ReturnDataSize,

    /// The value originated from the `SELFBALANCE` opcode.
    SelfBalance,

    /// The value was constructed by the analysis in order to aid the process.
    Synthetic,

    /// The value originated from an `MLOAD` from uninitialized memory.
    UninitializedMemory,

    /// The value originated from an `SLOAD` from uninitialized storage.
    UninitializedStorage,

    /// The data came from the data returned from a message call.
    MessageCall,

    /// There is no concrete source for this variable.
    Unknown,
}

#[cfg(test)]
mod test {
    use uuid::Uuid;

    use crate::vm::value::{SymbolicValue, SymbolicValueData};

    #[test]
    fn equality_ignores_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(0, data);

        assert_eq!(value_1, value_2);
    }

    #[test]
    fn equality_includes_provenance() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_from_execution(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert_ne!(value_1, value_2);
    }

    #[test]
    fn strict_equality_includes_instruction_pointer() {
        let id = Uuid::new_v4();
        let data = SymbolicValueData::Value { id };
        let value_1 = SymbolicValue::new_synthetic(0, data.clone());
        let value_2 = SymbolicValue::new_synthetic(1, data);

        assert!(!value_1.strict_eq(&value_2));
    }
}
